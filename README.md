# Конспект по C

## Особенности синтаксиса

### Особенности переменных

```с
char            // символьный и целочисленный тип
unsigned char   // беззнаковый
signed char     // знаковый (появился в ANSI C90)
```

Остальные целочисленные по умолчанию знаковые — short, int, long, long long
Вещественных беззнаковых не бывает

```с
unsigned double   // CE
```

### Операция присваивания

Под копотом происходти операция копирования
левый операнд = правый операнд

```c
var = 100;
```

var — Модифицируемое лево-допустимое (l-value)
100 — числовой литерал

```c
int var, size;
var = size = 100;
```

### Операция инициализации

```c
int var = 100;
```

### scanf

Возвращает число прочитанных элементов из потока stdin
К пробельным символам относят пробел, табуляцию, перевод строки:

```c
int cnt = scanf("%c %c", &byte1, &byte2);
```

#### Чтение double

```c
double d;
int cnt = scanf("%lf", &d);
```

```c
int a; short b; float c; double d;
int cnt = scanf("%d %hd %f %lf", &a, &b, &c, &d);
printf("%d %hd %.2f %.2f", a, b, c, d);
```

#### Проверка на число аргументов

```c
if (scanf("%d", &item != 1) {
    printf("Error input");
}
```

### printf

printf == print formatted

#### Таблица команд форматирования функции printf


|Код| Формат|
| - |:-------------:|
|%с |	Символ типа char|
|%d |	Десятичное число целого типа со знаком||
|%i |	Десятичное число целого типа со знаком|
|%е |	Научная нотация (е нижнего регистра)|
|%Е |	Научная нотация (Е верхнего регистра)|
|%f |	Десятичное число с плавающей точкой|
|%g |	Использует код %е или %f — тот из них, который короче (при использовании %g используется е нижнего регистра)|
|%G |	Использует код %Е или %f — тот из них, который короче (при использовании %G используется Е верхнего регистра)|
|%о |	Восьмеричное целое число без знака|
|%s |	Строка символов|
|%u |	Десятичное число целого типа без знака|
|%х |	Шестнадцатиричное целое число без знака (буквы нижнего регистра)|
|%Х | Шестнадцатиричное целое число без знака (буквы верхнего регистра)|
|%р |	Выводит на экран значение указателя|
|%n |	Ассоциированный аргумент — это указатель на переменную целого типа, в которую помещено количество символов, записанных на данный момент|
|%%	| Выводит символ %|

#### Таблица модификаторов типов printf

- l – суффикс для типов long или unsigned long;
- ll – суффикс для типов long long или unsigned long long.
- L – суффикс для типа long double.

#### Вывод времени hh:mm:ss

```c
unsigned char h = 11, m = 8, s = 1;
printf("%02d:%02d:%02d", h, m, s);
// 11:08:01
```

#### Вывод символа в текущей кодировке

```c
char ch = 'M';
printf("symbol: %c now code: %d", ch, ch);
```

### Этапы трансляции программы в машинный код.

q: Что называют модулем в проекте программы на языке Си?
a: Каждый отдельный файл с текстом программы

q: Какую роль играет текстовый препроцессор при компиляции программы на языке Си?
a: Обрабатывает директивы препроцессора в исходных файлах текстов программы

q: Какую роль играет непосредственно компилятор при транслировании программы на языке Си в машинный код?
a: Отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы

q: Какую роль играет линкер (редактор связей) при компиляции программы на языке Си?
a: Соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций

## Особенности вычисления

### При целочисленном делении дробная часть отбрасывается

```c
#include <stdio.h>
int main(void)
{
    printf("%d", 9/2);      // 4
    printf("%d", -9/2);     // -4
    return 0;
}
```

В сравнении с питоном:

```python
print (9//2)    # 4
print (-9//2)   # -5
```

### Остаток от деления

#### Работает только с целыми

```c
int var = 10 % 3      // Ok
double var = 10. % 3  // CE
```

#### Учитывается только знак делимого

```c
int res_1 = 10 % 4;     // 2
int res_1 = -10 % 4;    // -2
int res_1 = -10 % -4;   // -2
int res_1 = 10 % -4;    // 2
```

#### Вычисление остатка без деления без использования %

```c
int res = 10 - 10 / 3 * 3;
```

### Инкремент

```c
// Ok
d++;
++(b);
```

#### Error: lvalue required as increment operand

```c
10++;    // применен к числовому литералу
(b++)++;   // значение в скобках становится числом 
(d + 10)++;
```

#### Нельзя использовать инкрементируемое выражение два раза в одной формуле

Это приведет к ошибках вычисления в различных компиляторах. warning: [-Wunsequenced]
Так можно

```c
int size = 10, w = 8;
int res = size++ * w + 20;
// 100
```

Так нет

```c
int size = 10;
int res = (size - 1) * 5 + (++size - 1) * 2;
// warning: unsequenced modification and access to 'size' [-Wunsequenced]
```

### Арифметические операции +=, -=, *=, /=, %=

Сначала выполняются все действия справа от равно, потом слева.

```c
// Ok
int b = 1;
res = (b *= 5) - 10;
res %= (b -= 1) * 5;
printf("%d", (a *= 3) * (b -= 10)); // скобки обязательно
// CE
int res += 10 / 2;  // ошибка именно в int
```

### Булевы величины

true — любое не нулевое
false — 0

#### с99

_Bool var = 0;
размер — минимальное допустимое целочисленное значение
_Bool var = 10; // приведется к 1
Для использования bool:

```c
#include <stdbool.h>
bool b = true;
```

#### Операции сравнения

с == использовать только целые числа

- Проверка слева на право
- Лишние вычисления не делаются

```
bool div_enable = x != 0 && 10 / x > 1;  // при x = 0, дальше не проверяется
```

## Операторы ветвления

### Условная тернарная операция

Всегда возвращает определенный результат
Операция может быть частью выражения или аргументом функции
max = a > b ? a : b;
Приоритет ? : ниже всего, кроме присваивания

```c
max = (a > b) ? (a > c ? a : c) : (b > c) ? b : c;
// скобки вложенной тернарной операции обязательные из-за низкого приоритета по сравнению со сравнением
```

### Оператор switch

- Внутри switch может быть любая конструкция, возвращающая целочисленное значение.
- После ключевого слова case должны быть прописаны целочисленные, **вычисляемые на этапе компиляции программы** === целочисленная метка времени компиляции программы
- Операторы после case могут отсутствовать.
- После срабанывания case будут выведены все последующие значения, если не было break
- default в си не обязательный. Вместо default можно использовать return 0.
- Метки case просматриваются строго сверху-вниз

#### Рекомендации

В реальной практике он нередко разрастается до больших размеров и затрудняет восприятие текста программы. Поэтому есть несколько рекомендаций, которых следует придерживаться при использовании оператора switch:

- оператор switch лучше выносить в отдельную функцию и прерывать его работы с помощью оператора return;
- программу следует организовывать так, чтобы после каждой метки case прописывался вызов некоторой функции вместо набора операторов;
- никогда в программах не используйте вложенные операторы switch.

## Битовые операции
Приоритет по возрастанию: |, ^, & , ~
Приоритет сдвиговых битовых операций << и >> одинаковый, но выше, чем у операций сравнений и меньше чем у арифметических операций.

#### Проверка включенных бит
> Note: Не забывай про скобки
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 5;  //двоичная запись 00000101
    unsigned char mask = 4;   //двоичная запись 00000100
 
    if((flags & mask) == mask)
        printf("bit 2 is on");
    else
        printf("bit 2 is off");
 
    return 0;
}
```

#### Выключение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 13;  //двоичная запись 00001101
    unsigned char mask = 5;    //двоичная запись 00000101
 
    flags = flags & ~mask;
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### Включение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 8;    //двоичная запись 00001000
    unsigned char mask = 5;     //двоичная запись 00000101
 
    flags = flags | mask;       //двоичная запись 00001101 (число 13)
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### Переключение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 9;    //двоичная запись 00001001
    unsigned char mask = 1;     //двоичная запись 00000001
 
    flags = flags ^ mask;       //двоичная запись 00001000 (число 8)
 
    printf("flags = %d\n", flags);
 
    flags ^= mask;              //двоичная запись 00001001 (число 9)
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### XOR, дважды примененная маска дает исходное значение
Двойное переключение даст исходный результат. Где этот эффект можно применить? Самое простое – в шифровании данных. Например, когда у нас есть сообщение в виде набора данных и маска – как шифровальный ключ. Тогда, к каждому блоку данных можно применить маску и, таким образом, зашифровать сообщение. В частности по такому принципу устроена защита по паролю в архиваторе zip. Причем, сам пароль является ключом, который накладывается по XOR на заархивированные данные.

#### Поменять местами 2 переменные без использования третьей
```c
#include <stdio.h>
int main(void)
{
    unsigned char a = 3, b = 9;
    printf("before: %d %d\n", a, b);
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
    printf("after: %d %d\n", a, b);
    return 0;
}
```

#### При сдвиге вправо знаковых переменных, знаковый бит дублируется
```c
#include <stdio.h>
 
int main(void)
{
    signed char x = -128;        // 1000 0000
    printf("x = %d\n", x);
 
    x = x << 1;                  // 0000 0000
    printf("x = %d\n", x);
 
    x = -128;                    // 1000 0000
    x = x >> 1;                  // 1100 0000 (-64)
    printf("x = %d\n", x);
 
    return 0;
}
```

## Генерация псевдослучайных чисел
- Числа, генерируемые функцией rand(), распределены по равномерному закону (равновероятны)
- Функция rand() выдает числа в диапазоне [0; RAND_MAX]
### Каждый раз будет один и тот же результат
```c

#include <stdio.h>
#include <stdlib.h> // библиотека с rand()

int main(void)
{
    printf("%d, %d, %d\n", rand(), rand(), rand());
    return 0;
}
```
### Разные числа
```c

#include <stdio.h>
#include <stdlib.h> // библиотека с rand()
#include <time.h>   // библиотека с time()

int main(void)
{
    srand(time(NULL));
    printf("%d, %d, %d\n", rand(), rand(), rand());
    return 0;
}
```
### Задание диапазона
```c
int r_1 = rand() % range;       // [0, range)
int r_1 = rand() % range - 5;   // [5, range - 5)
int r_3 = rand() + rand();      // больше RAND_MAX >= 32767
int r_4 = rand() % (b - a + 1) + a; // [a, b] при (a < b)
double range_float = (double)rand() / (double)RAND_MAX; // [0, 1]
double range_map = (double)rand() / RAND_MAX * (b - a) + a  // [0, RAND_MAX] -> [a, b]
```

## <math.h> Основные функции
> Note: Надо следить за типом передаваемых значений.

|Функция| Описание|
| - |:-------------:|
|int abs(int) |	Вычисление модуля целочисленного значения|
|double fabs(double) |	Вычисление модуля вещественного значения|
|double round(double) |	Округление вещественного значения до ближайшего целого|
|double floor(double) |	Округление вещественного значения до наименьшего целого|
|double ceil(double) | Округление вещественного значения до наибольшего целого|
|double trunc(double)| Отбрасывание дробной части вещественного числа|
|double sqrt(double) | Вычисление квадратного корня от вещественного значения|
|double cbrt(double) | Вычисление кубического корня от вещественного значения|
|double pow(double x, double y)| |
|double exp(double) | Вычисление экспоненты от вещественного значения|
|double log(double) | Вычисление натурального логарифма.|
|double log2(double) | Вычисление логарифма по основанию 2|
|double log10(double) |	Вычисление десятичного логарифма|
|double sin(double) |	Вычисление синуса угла, заданного в радианах|
|double cos(double) |	Вычисление косинуса угла, заданного в радианах|
|double tan(double) |	Вычисление тангенса угла, заданного в радианах|
|double asin(double) |	Вычисление арксинуса угла (возвращает радианы)|
|double acos(double) |	Вычисление арккосинуса угла (возвращает радианы)|
|double atan(double) |	Вычисление арктангенса угла (возвращает радианы)|

## Макросы 
- имена макросов принято записывать заглавными буквами
- макроимена не подставляются внутри строк 
- макроопределения обрабатываются до непосредственной компиляции программы
```c
#define  10
printf("DIGIT"); // DIGIT
```
- Можно переопределять макросы через #undef
```c
#undef DIGIT
#define DIGIT 5
```

# todo

- написать прогу для вывода места, занимаемого всеми типами данных