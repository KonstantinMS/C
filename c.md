# Конспект по C

## Особенности синтаксиса

### Особенности переменных

```с
char            // символьный и целочисленный тип
unsigned char   // беззнаковый
signed char     // знаковый (появился в ANSI C90)
```

Остальные целочисленные по умолчанию знаковые — short, int, long, long long
Вещественных беззнаковых не бывает

```с
unsigned double   // CE
```

### Операция присваивания

Под копотом происходти операция копирования
левый операнд = правый операнд

```c
var = 100;
```

var — Модифицируемое лево-допустимое (l-value)
100 — числовой литерал

```c
int var, size;
var = size = 100;
```

### Операция инициализации

```c
int var = 100;
```

### scanf

Возвращает число прочитанных элементов из потока stdin
К пробельным символам относят пробел, табуляцию, перевод строки:

```c
int cnt = scanf("%c %c", &byte1, &byte2);
```

#### Чтение double

```c
double d;
int cnt = scanf("%lf", &d);
```

```c
int a; short b; float c; double d;
int cnt = scanf("%d %hd %f %lf", &a, &b, &c, &d);
printf("%d %hd %.2f %.2f", a, b, c, d);
```

#### Проверка на число аргументов

```c
if (scanf("%d", &item != 1) {
    printf("Error input");
}
```

### printf

printf == print formatted

#### Таблица команд форматирования функции printf


|Код| Формат|
| - |:-------------:|
|%с |	Символ типа char|
|%d |	Десятичное число целого типа со знаком||
|%i |	Десятичное число целого типа со знаком|
|%е |	Научная нотация (е нижнего регистра)|
|%Е |	Научная нотация (Е верхнего регистра)|
|%f |	Десятичное число с плавающей точкой|
|%g |	Использует код %е или %f — тот из них, который короче (при использовании %g используется е нижнего регистра)|
|%G |	Использует код %Е или %f — тот из них, который короче (при использовании %G используется Е верхнего регистра)|
|%о |	Восьмеричное целое число без знака|
|%s |	Строка символов|
|%u |	Десятичное число целого типа без знака|
|%х |	Шестнадцатиричное целое число без знака (буквы нижнего регистра)|
|%Х | Шестнадцатиричное целое число без знака (буквы верхнего регистра)|
|%р |	Выводит на экран значение указателя|
|%n |	Ассоциированный аргумент — это указатель на переменную целого типа, в которую помещено количество символов, записанных на данный момент|
|%%	| Выводит символ %|

#### Таблица модификаторов типов printf

- l – суффикс для типов long или unsigned long;
- ll – суффикс для типов long long или unsigned long long.
- L – суффикс для типа long double.

#### Вывод времени hh:mm:ss

```c
unsigned char h = 11, m = 8, s = 1;
printf("%02d:%02d:%02d", h, m, s);
// 11:08:01
```

#### Вывод символа в текущей кодировке

```c
char ch = 'M';
printf("symbol: %c now code: %d", ch, ch);
```

### Этапы трансляции программы в машинный код.

q: Что называют модулем в проекте программы на языке Си?  
a: Каждый отдельный файл с текстом программы

q: Какую роль играет текстовый препроцессор при компиляции программы на языке Си?  
a: Обрабатывает директивы препроцессора в исходных файлах текстов программы

q: Какую роль играет непосредственно компилятор при транслировании программы на языке Си в машинный код?  
a: Отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы

q: Какую роль играет линкер (редактор связей) при компиляции программы на языке Си?  
a: Соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций

## Особенности вычисления

### При целочисленном делении дробная часть отбрасывается

```c
#include <stdio.h>
int main(void)
{
    printf("%d", 9/2);      // 4
    printf("%d", -9/2);     // -4
    return 0;
}
```

В сравнении с питоном:

```python
print (9//2)    # 4
print (-9//2)   # -5
```

### Остаток от деления

#### Работает только с целыми

```c
int var = 10 % 3      // Ok
double var = 10. % 3  // CE
```

#### Учитывается только знак делимого

```c
int res_1 = 10 % 4;     // 2
int res_1 = -10 % 4;    // -2
int res_1 = -10 % -4;   // -2
int res_1 = 10 % -4;    // 2
```

#### Вычисление остатка без деления без использования %

```c
int res = 10 - 10 / 3 * 3;
```

### Инкремент

```c
// Ok
d++;
++(b);
```

#### Error: lvalue required as increment operand

```c
10++;    // применен к числовому литералу
(b++)++;   // значение в скобках становится числом 
(d + 10)++;
```

#### Нельзя использовать инкрементируемое выражение два раза в одной формуле

Это приведет к ошибках вычисления в различных компиляторах. warning: [-Wunsequenced]
Так можно

```c
int size = 10, w = 8;
int res = size++ * w + 20;
// 100
```

Так нет

```c
int size = 10;
int res = (size - 1) * 5 + (++size - 1) * 2;
// warning: unsequenced modification and access to 'size' [-Wunsequenced]
```

### Арифметические операции +=, -=, *=, /=, %=

Сначала выполняются все действия справа от равно, потом слева.

```c
// Ok
int b = 1;
res = (b *= 5) - 10;
res %= (b -= 1) * 5;
printf("%d", (a *= 3) * (b -= 10)); // скобки обязательно
// CE
int res += 10 / 2;  // ошибка именно в int
```

### Булевы величины

true — любое не нулевое
false — 0

#### с99

_Bool var = 0;
размер — минимальное допустимое целочисленное значение
_Bool var = 10; // приведется к 1
Для использования bool:

```c
#include <stdbool.h>
bool b = true;
```

#### Операции сравнения

с == использовать только целые числа

- Проверка слева на право
- Лишние вычисления не делаются

```
bool div_enable = x != 0 && 10 / x > 1;  // при x = 0, дальше не проверяется
```

## Операторы ветвления

### Условная тернарная операция

Всегда возвращает определенный результат
Операция может быть частью выражения или аргументом функции
max = a > b ? a : b;
Приоритет ? : ниже всего, кроме присваивания

```c
max = (a > b) ? (a > c ? a : c) : (b > c) ? b : c;
// скобки вложенной тернарной операции обязательные из-за низкого приоритета по сравнению со сравнением
```

### Оператор switch

- Внутри switch может быть любая конструкция, возвращающая целочисленное значение.
- После ключевого слова case должны быть прописаны целочисленные, **вычисляемые на этапе компиляции программы** === целочисленная метка времени компиляции программы
- Операторы после case могут отсутствовать.
- После срабанывания case будут выведены все последующие значения, если не было break
- default в си не обязательный. Вместо default можно использовать return 0.
- Метки case просматриваются строго сверху-вниз

#### Рекомендации

В реальной практике он нередко разрастается до больших размеров и затрудняет восприятие текста программы. Поэтому есть несколько рекомендаций, которых следует придерживаться при использовании оператора switch:

- оператор switch лучше выносить в отдельную функцию и прерывать его работы с помощью оператора return;
- программу следует организовывать так, чтобы после каждой метки case прописывался вызов некоторой функции вместо набора операторов;
- никогда в программах не используйте вложенные операторы switch.

## Битовые операции
Приоритет по возрастанию: |, ^, & , ~
Приоритет сдвиговых битовых операций << и >> одинаковый, но выше, чем у операций сравнений и меньше чем у арифметических операций.

#### Проверка включенных бит
> Note: Не забывай про скобки
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 5;  //двоичная запись 00000101
    unsigned char mask = 4;   //двоичная запись 00000100
 
    if((flags & mask) == mask)
        printf("bit 2 is on");
    else
        printf("bit 2 is off");
 
    return 0;
}
```

#### Выключение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 13;  //двоичная запись 00001101
    unsigned char mask = 5;    //двоичная запись 00000101
 
    flags = flags & ~mask;
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### Включение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 8;    //двоичная запись 00001000
    unsigned char mask = 5;     //двоичная запись 00000101
 
    flags = flags | mask;       //двоичная запись 00001101 (число 13)
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### Переключение определенных бит
```c
#include <stdio.h>
 
int main(void)
{
    unsigned char flags = 9;    //двоичная запись 00001001
    unsigned char mask = 1;     //двоичная запись 00000001
 
    flags = flags ^ mask;       //двоичная запись 00001000 (число 8)
 
    printf("flags = %d\n", flags);
 
    flags ^= mask;              //двоичная запись 00001001 (число 9)
    printf("flags = %d\n", flags);
 
    return 0;
}
```

#### XOR, дважды примененная маска дает исходное значение
Двойное переключение даст исходный результат. Где этот эффект можно применить? Самое простое – в шифровании данных. Например, когда у нас есть сообщение в виде набора данных и маска – как шифровальный ключ. Тогда, к каждому блоку данных можно применить маску и, таким образом, зашифровать сообщение. В частности по такому принципу устроена защита по паролю в архиваторе zip. Причем, сам пароль является ключом, который накладывается по XOR на заархивированные данные.

#### Поменять местами 2 переменные без использования третьей
```c
#include <stdio.h>
int main(void)
{
    unsigned char a = 3, b = 9;
    printf("before: %d %d\n", a, b);
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
    printf("after: %d %d\n", a, b);
    return 0;
}
```

#### При сдвиге вправо знаковых переменных, знаковый бит дублируется
```c
#include <stdio.h>
 
int main(void)
{
    signed char x = -128;        // 1000 0000
    printf("x = %d\n", x);
 
    x = x << 1;                  // 0000 0000
    printf("x = %d\n", x);
 
    x = -128;                    // 1000 0000
    x = x >> 1;                  // 1100 0000 (-64)
    printf("x = %d\n", x);
 
    return 0;
}
```

## Генерация псевдослучайных чисел
- Числа, генерируемые функцией rand(), распределены по равномерному закону (равновероятны)
- Функция rand() выдает числа в диапазоне [0; RAND_MAX]
### Каждый раз будет один и тот же результат
```c

#include <stdio.h>
#include <stdlib.h> // библиотека с rand()

int main(void)
{
    printf("%d, %d, %d\n", rand(), rand(), rand());
    return 0;
}
```
### Разные числа
```c

#include <stdio.h>
#include <stdlib.h> // библиотека с rand()
#include <time.h>   // библиотека с time()

int main(void)
{
    srand(time(NULL));
    printf("%d, %d, %d\n", rand(), rand(), rand());
    return 0;
}
```
### Задание диапазона
```c
int r_1 = rand() % range;       // [0, range)
int r_1 = rand() % range - 5;   // [5, range - 5)
int r_3 = rand() + rand();      // больше RAND_MAX >= 32767
int r_4 = rand() % (b - a + 1) + a; // [a, b] при (a < b)
double range_float = (double)rand() / (double)RAND_MAX; // [0, 1]
double range_map = (double)rand() / RAND_MAX * (b - a) + a  // [0, RAND_MAX] -> [a, b]
```

## <math.h> Основные функции
> Note: Надо следить за типом передаваемых значений.

|Функция| Описание|
| - |:-------------:|
|int abs(int) |	Вычисление модуля целочисленного значения|
|double fabs(double) |	Вычисление модуля вещественного значения|
|double round(double) |	Округление вещественного значения до ближайшего целого|
|double floor(double) |	Округление вещественного значения до наименьшего целого|
|double ceil(double) | Округление вещественного значения до наибольшего целого|
|double trunc(double)| Отбрасывание дробной части вещественного числа|
|double sqrt(double) | Вычисление квадратного корня от вещественного значения|
|double cbrt(double) | Вычисление кубического корня от вещественного значения|
|double pow(double x, double y)| |
|double exp(double) | Вычисление экспоненты от вещественного значения|
|double log(double) | Вычисление натурального логарифма.|
|double log2(double) | Вычисление логарифма по основанию 2|
|double log10(double) |	Вычисление десятичного логарифма|
|double sin(double) |	Вычисление синуса угла, заданного в радианах|
|double cos(double) |	Вычисление косинуса угла, заданного в радианах|
|double tan(double) |	Вычисление тангенса угла, заданного в радианах|
|double asin(double) |	Вычисление арксинуса угла (возвращает радианы)|
|double acos(double) |	Вычисление арккосинуса угла (возвращает радианы)|
|double atan(double) |	Вычисление арктангенса угла (возвращает радианы)|

## Макросы 
- действие макроопределений распространяется только на текущий модуль
- имена макросов принято записывать заглавными буквами
- макроимена не подставляются внутри строк 
- макроопределения обрабатываются до непосредственной компиляции программы
- препроцессор на место записи директивы #include вставляет содержимое указанного файла
```c
#define DIGIT 10
printf("%d", DIGIT); // 10
printf("DIGIT"); // DIGIT
```
- Можно переопределять макросы через #undef
```c
#undef DIGIT
#define DIGIT 5
```
- Переменные нужно брать в скобки
```c
#include <stdio.h>
#define MUL(X, Y)     ((X) * (Y))
int main(void){
    int a = 2, b = 5;
    int res_mul = MUL(a + 2, b - 1);
    printf("%d", res_mul);
    return 0;
}
```
- операция ## служит для склейки двух лексем в одну
```c
#define RES_N(RES)     res_ ## RES
RES_N(1) // res_1
```
Пример: ограничения максимального значения
```c
#define MAX_WIDTH       1280
#define GET_WIDTH(W)    (W) < MAX_WIDTH ? (W) : MAX_WIDTH
```
Пример: поиск максимума
```c
#define GET_MAX(X, Y) (X > Y ? X : Y)
#define GET_MAX(X, Y) ((X) > (Y) ? (X) : (Y))
// Оба ок для GET_MAX(val_1 + 1, val_2 - 1)
```
Тонкости использования
```c
const int max_size = 5;
#define SIZE    1
#define IS_CPP

#if defined(SIZE) ... #endif    // OK
#ifdef IS_CPP ... #endif    // OK
#if SIZE >= 0 && SIZE <= 10 ... #endif    // OK
#ifndef IS_CPP ... #endif    // OK
#if SIZE > 10 - 8 ... #endif    // OK
#if SIZE > 0 ... #endif    // OK
#ifdef(IS_CPP) ... #endif     // CE, скобки macro names must be identifiers
#if IS_CPP ... #endif   // CE, нет значения #if with no expression
#if max_size > 1 ... #endif // не корректно работает, зайдет в условие только если !max_size
#if !defined(SIZE) ... #endif    // OK
#if(SIZE == 1) ... #endif    // OK
```
## Циклы
### while
Цикл с предусловием
- выполнение операций слева направо
```c
int i = 0;
while (++i <= n && i <=10)  // сначала делается все до && (||)
```
Пример: Читаем числа, пока не встретим 0 или не целое число или буквы. Причем 1.25 воспримет как 1.
```c
#include <stdio.h>
 int main(void)
{
    int s = 0, x ;
    while(scanf("%d", &x) == 1 && x != 0)
        printf("%d ", x * x);
    return 0;
}
```
Пример: найти сумму квадратов n чисел
```c
#include <stdio.h>
int main(void)
{
    int n, s = 0;
    if(scanf("%d", &n) != 1) {
        printf("Error input\n");
        return 0;
    }
    while(n > 0) {
        s += n*n;
        n--;
    }
    printf("s = %d\n", s);
    return 0;
}
```
Пример: последовательность Фибоначчи 
```c
#include <stdio.h> 
int Fib(int i){
    if(i <= 1) return i;
    return Fib(i-1) + Fib(i - 2);
}
int main(){
    int n, i = 0;
    scanf("%d", &n);
    while(i++ < n) printf("%d ", Fib(i));
    return 0;
}
```
Пример: палиндром
```
#include <stdio.h>
int isPalindrome(int num) {
    int reversedNum = 0;
    int originalNum = num;
    while (num > 0) {
        int digit = num % 10;
        reversedNum = reversedNum * 10 + digit;
        num /= 10;
    }
    return originalNum == reversedNum;
}

int main() {
    int number;
    scanf("%d", &number);
    
    if (isPalindrome(number))
        printf("yes");
    else
        printf("no");
    return 0;
}
```
Пример: наибольший общий делитель (НОД) двух натуральных чисел
```c
#include <stdio.h>
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
int main() {
    int num1, num2;
    scanf("%d %d", &num1, &num2);
    int result = gcd(num1, num2);
    printf("%d", result);
    return 0;
}
```
### for
Цикл for языка Си стандарта C99 и выше:
- цикл for записывается по синтаксису: for([инициализация]; [условие]; [изменение значений]) оператор;
- в блоке инициализации цикла for можно объявлять и инициализировать новые переменные
- цикл for работает, пока истинно условие цикла
- цикл for сначала проверяет условие, а затем, выполняет очередную итерацию
- блок "изменение значений" выполняется сразу после очередной итерации тела цикла

# todo

- написать прогу для вывода места, занимаемого всеми типами данных

# makefile

# bash